# freeCodeCamp - Scientific Computing with Python Learning Path

This repository archives my work on the guided projects and exercises from the freeCodeCamp "Scientific Computing with Python" curriculum. These projects were completed as part of the learning process leading up to the final certification projects.

Each folder in this repository represents a self-contained project or concept, demonstrating the application of fundamental and advanced Python principles.

---

## Completed Projects & Exercises

Here is a list of the projects currently included in this repository:

*   **Vigen√®re Cipher:** An implementation of the classic polyalphabetic substitution cipher, focusing on string manipulation and modular arithmetic.
*   **Expense Tracker:** A simple command-line application to track and filter personal expenses, demonstrating data structures and user input handling.
*   **Square Root (Bisection Method):** A function to find the square root of a number using the bisection numerical method, highlighting algorithmic thinking.
*   **Luhn Algorithm:** An implementation of the checksum formula used to validate identification numbers like credit card numbers.
*   **Case Converter:** A script to convert strings between different programming case styles (e.g., snake_case, PascalCase).
*   **Password Generator:** A robust script for creating cryptographically strong, random passwords. It leverages Python's `secrets` module for security and the `re` module to enforce customizable constraints, such as minimum length and required counts of uppercase letters, numbers, and special characters.
*   **Dijkstra's Shortest Path Algorithm:** An implementation of the classic Dijkstra's algorithm to find the shortest path between nodes in a weighted graph. This project demonstrates the use of data structures like dictionaries and lists to manage distances and paths, and algorithmic concepts such as greedy approaches by iteratively selecting the node with the minimum distance.
*   **Tower of Hanoi:** A classic recursive solution to the Tower of Hanoi puzzle. This project is a prime example of solving a complex problem by breaking it down into smaller, identical sub-problems, showcasing the power and elegance of recursive thinking.
*   **Merge Sort Algorithm:** A classic implementation of the Merge Sort algorithm, a highly efficient, comparison-based sorting algorithm. This project showcases the "Divide and Conquer" paradigm, using recursion to break down the problem and iterative merging to build the solution.
*   **Sudoku Solver:** A class-based Sudoku solver that uses a  recursive backtracking algorithm.
*   **Binary Search Tree (BST):** A robust implementation of the Binary Search Tree data structure. This project demonstrates key computer science concepts including object-oriented design, recursion for core operations (insert, search, delete), and handling complex cases like node deletion with two children by finding the in-order successor.
*   **Vector Space:** A project demonstrating advanced object-oriented design in Python through the implementation of vector space objects. Key concepts include **operator overloading** (using dunder methods like `__add__`, `__mul__`, `__eq__`) to enable intuitive, mathematical syntax. The code showcases **inheritance** for code reuse (`R3Vector` extends `R2Vector`) and employs dynamic, attribute-driven logic to remain highly generic and scalable.
*   **Equation Solver:** A robust, extensible framework for solving mathematical equations, showcasing advanced Python features. This project is built around an **Abstract Base Class (ABC)** that enforces a contract for subclasses. It demonstrates **polymorphism**, **inheritance**, and **metaprogrammation** (`__init_subclass__`) for creating a scalable system. The solver function utilizes modern **pattern matching (`match/case`)** for elegant handling of results and details.
*   **Projectile Trajectory Calculator:** An object-oriented simulation of projectile motion. This project demonstrates advanced OOP concepts such as **encapsulation** with private attributes, **properties and setters** for controlled data access, and memory optimization using **`__slots__`**. It showcases a clear **separation of concerns** between the physics logic (`Projectile` class) and the data presentation (`Graph` class), which generates both a data table and a text-based trajectory plot.


*(This list will be updated as I complete more exercises in the curriculum.)*

---

You can find the five final, graded projects for my certification in their own dedicated repositories on my GitHub profile.
